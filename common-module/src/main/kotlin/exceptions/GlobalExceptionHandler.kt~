package com.buoyancy.common.exceptions

import com.buoyancy.common.model.dto.rest.MessageDto
import com.buoyancy.common.utils.get
import io.github.oshai.kotlinlogging.KotlinLogging
import org.postgresql.util.PSQLException
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.context.MessageSource
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.http.HttpStatus.*
import org.springframework.http.ResponseEntity
import org.springframework.validation.FieldError
import org.springframework.validation.ObjectError
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseStatus
import org.springframework.web.bind.annotation.RestControllerAdvice

@RestControllerAdvice
class GlobalExceptionHandler {

    private val log = KotlinLogging.logger {}

    @Autowired
    private lateinit var messages : MessageSource

    @ResponseStatus(BAD_REQUEST)
    @ExceptionHandler( BadRequestException::class )
    fun processBadRequestException(exception: BadRequestException): MessageDto {
        log.error { "Bad request exception thrown: ${ exception.message }" }
        return MessageDto(
            BAD_REQUEST.value(),
            exception.message ?: messages.get("rest.exceptions.bad-request")
        )
    }

    @ResponseStatus(CONFLICT)
    @ExceptionHandler(ConflictException::class )
    fun processConflictException(exception: ConflictException): MessageDto {
        log.error { "Conflict exception thrown: ${ exception.message }" }
        return MessageDto(
            CONFLICT.value(),
            exception.message ?: messages.get("rest.exceptions.conflict")
        )
    }

    @ResponseStatus(INTERNAL_SERVER_ERROR)
    @ExceptionHandler(InternalErrorException::class )
    fun processInternalErrorException(exception: InternalErrorException): MessageDto {
        log.error { "Internal error exception thrown: ${ exception.message }" }
        return MessageDto(
            INTERNAL_SERVER_ERROR.value(),
            exception.message ?: messages.get("rest.exceptions.internal-error")
        )
    }

    @ResponseStatus(NOT_FOUND)
    @ExceptionHandler(NotFoundException::class )
    fun processNotFoundException(exception: NotFoundException): MessageDto {
        log.error { "Not found exception thrown: ${ exception.message }" }
        return MessageDto(
            NOT_FOUND.value(),
            exception.message ?: messages.get("rest.exceptions.not-found")
        )
    }

    @ResponseStatus(UNAUTHORIZED)
    @ExceptionHandler(UnauthorizedException::class )
    fun processUnauthorizedException(exception: UnauthorizedException): MessageDto {
        log.error { "Unauthorized exception thrown: ${ exception.message }" }
        return MessageDto(
            UNAUTHORIZED.value(),
            exception.message ?: messages.get("rest.exceptions.unauthorized")
        )
    }

    @ResponseStatus(BAD_REQUEST)
    @ExceptionHandler(DataIntegrityViolationException::class)
    fun handleDataIntegrity(e: DataIntegrityViolationException): MessageDto {
        val rootCause = e.rootCause

        val errorMessage = if (rootCause is PSQLException) {
            when (rootCause.sqlState) {
                "23502" -> messages.get("exceptions.psql.not-null") // NOT NULL violation
                "23503" -> messages.get("exceptions.psql.foreign-key") // FOREIGN KEY violation
                "23505" -> messages.get("exceptions.psql.unique") // UNIQUE violation
                else -> messages.get("exceptions.psql.unknown")
            }
        } else { messages.get("exceptions.sql.unknown") }
        return MessageDto(BAD_REQUEST.value(), errorMessage)
    }

    @ResponseStatus(BAD_REQUEST)
    @ExceptionHandler( MethodArgumentNotValidException::class )
    fun processValidationException(exception: MethodArgumentNotValidException): ResponseEntity<MessageDto> {

        log.error { "Validation exception thrown: ${ exception.message }" }
        val status = INTERNAL_SERVER_ERROR.value()
        val errors = exception.bindingResult.allErrors

        return ResponseEntity.status(status)
            .body(MessageDto(
                statusCode = status,
                message = if (errors.isNotEmpty()) buildValidationErrorMessage(errors) else "Bad request"
            ))
    }

    private fun buildValidationErrorMessage(errors : List<ObjectError>): String {
        val str = StringBuilder()
        for (e in errors) {
            val fieldError = e as FieldError
            str.append(fieldError.field)
                .append('=')
                .append(fieldError.rejectedValue)
                .append(", ")
        }
        str.deleteCharAt(str.length - 1)
        str.deleteCharAt(str.length - 1)
        return str.toString()
    }
}